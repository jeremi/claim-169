#!/usr/bin/env python3
"""Generate docs/en/sdk/java/api.md from compiled JVM classes using javap.

This script introspects the Java-facing API in package `fr.acn.claim169`
from compiled class files and emits a Markdown reference page.
"""

from __future__ import annotations

import argparse
import subprocess
from pathlib import Path


SKIP_CLASS_NAMES = {
    "DecoderBuilderKt",
    "Claim169Builders",
}


def run_javap(classpath: Path, fqcn: str) -> str:
    cmd = ["javap", "-classpath", str(classpath), "-public", fqcn]
    result = subprocess.run(cmd, capture_output=True, text=True, check=False)
    if result.returncode != 0:
        raise RuntimeError(f"javap failed for {fqcn}:\n{result.stderr.strip()}")
    return result.stdout


def clean_member_line(line: str) -> str | None:
    line = line.strip()
    if not line or line in {"{", "}"}:
        return None

    # Remove members that are Kotlin/JVM internals or not useful for Java docs.
    blocked_fragments = (
        " INSTANCE;",
        " Companion;",
        " getEntries();",
        "$claim169_core",
        " access$",
        "kotlin.jvm.functions.Function1",
        "DefaultConstructorMarker",
    )
    if any(fragment in line for fragment in blocked_fragments):
        return None

    # Drop fully-qualified package prefixes for readability.
    replacements = {
        "java.lang.": "",
        "fr.acn.claim169.": "",
        "uniffi.claim169_jni.": "",
        "kotlin.jvm.functions.": "",
        "kotlin.enums.": "",
    }
    for old, new in replacements.items():
        line = line.replace(old, new)
    return line


def parse_javap_output(raw: str) -> tuple[str, list[str]]:
    header = ""
    members: list[str] = []
    for raw_line in raw.splitlines():
        line = raw_line.rstrip()
        if not line:
            continue
        if line.startswith("Compiled from"):
            continue
        if line.startswith("public ") and line.endswith("{") and not header:
            header = line[:-1].rstrip()
            continue
        if line == "}":
            continue
        cleaned = clean_member_line(line)
        if cleaned:
            members.append(cleaned)

    if not header:
        raise ValueError("Unable to parse class header from javap output")
    return header, members


def class_kind(header: str) -> str:
    if " interface " in f" {header} ":
        return "interfaces"
    if " extends Enum<" in header or " extends java.lang.Enum<" in header:
        return "enums"
    return "classes"


def discover_classes(class_dir: Path) -> list[str]:
    package_dir = class_dir / "fr" / "acn" / "claim169"
    if not package_dir.exists():
        raise FileNotFoundError(f"Package directory not found: {package_dir}")

    names: list[str] = []
    for class_file in sorted(package_dir.glob("*.class")):
        name = class_file.stem
        if "$" in name:
            continue
        if name in SKIP_CLASS_NAMES:
            continue
        names.append(name)
    return names


def render_markdown(classpath: Path, class_names: list[str]) -> str:
    grouped: dict[str, list[tuple[str, str, list[str]]]] = {
        "classes": [],
        "interfaces": [],
        "enums": [],
    }

    for class_name in class_names:
        fqcn = f"fr.acn.claim169.{class_name}"
        output = run_javap(classpath, fqcn)
        header, members = parse_javap_output(output)
        if not members and class_kind(header) == "classes":
            continue
        grouped[class_kind(header)].append((class_name, header, members))

    lines: list[str] = []
    lines.append("# API Reference")
    lines.append("")
    lines.append(
        "Complete API documentation for the claim169 Java SDK, auto-generated from compiled source using `javap`."
    )
    lines.append("")
    lines.append(
        "**Do not edit this file directly.** Regenerate with `python3 scripts/generate-java-api-docs.py`."
    )
    lines.append("")
    lines.append("Package prefixes are omitted in signatures for readability.")
    lines.append("")

    section_order = [
        ("classes", "Classes"),
        ("interfaces", "Interfaces"),
        ("enums", "Enums"),
    ]
    for key, title in section_order:
        entries = grouped[key]
        if not entries:
            continue
        lines.append(f"## {title}")
        lines.append("")
        for class_name, header, members in sorted(entries, key=lambda x: x[0].lower()):
            lines.append(f"### {class_name}")
            lines.append("")
            lines.append("```java")
            lines.append(f"{header} {{")
            for member in members:
                lines.append(f"  {member}")
            lines.append("}")
            lines.append("```")
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate Java API docs from compiled claim169 JVM classes"
    )
    parser.add_argument(
        "--class-dir",
        type=Path,
        default=Path("sdks/kotlin/claim169-core/build/classes/kotlin/main"),
        help="Classpath root containing compiled classes",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("docs/en/sdk/java/api.md"),
        help="Output markdown file path",
    )
    args = parser.parse_args()

    class_names = discover_classes(args.class_dir)
    markdown = render_markdown(args.class_dir, class_names)

    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(markdown, encoding="utf-8")

    print(f"Generated {args.output} from {len(class_names)} classes")


if __name__ == "__main__":
    main()
